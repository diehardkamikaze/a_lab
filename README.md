# a_lab


npm i
npm run test



/*
  1. В задании дается множество (в виде неупорядоченный массива), которое нужно сериализовать и десериализовать.
  Поскольку массив неупорядочен, в результате десериализации не обязательно сохранять порядок исходного массива.
  Сразу приходит на ум решение с подсчетом всех чисел в массиве и сериализация в строку в виде число+количесто, но
  пограничный случай с уникальными элементами не сработает. 

  2. Каждый ASCII символ в строке js занимает n бит.
  Простая сериализации переводит каждую цифру каждого элемента массива в char представление, все они находятся в диапазоне ASCII, т.е
  каждый из них займет также n бит.
  Например [1, 53, 52] после простой сериализации будет выглядеть как '1,53,52' (разделитель здесь запятая, но может быть любым или отсутсвовать).
  Без учета разделителя займет в памяти 5*n бит.

  3. В таблице ASCII 128 первых символов гарантиованно неизменяемы. Ими я могу закодировать, например 127 первых чисел (т.к 0 не входит в диапазон).
  Таким образом, например, числа от [ 1 до 127 ] можно представить в виде ASCII символов.

  4. В массиве содержатся однозначные, двузначные и трехзначные числа, занимающие при простой сериализации n, n*2 и n*3 бит соответственно.
  Используя сопоставление числа и ASCII символа можно сократить n*2 и n*3 битные представления чисел до n битных.
  Однако однозначные числа, т.е n-битные сократить не удастся, выдаст те же n бит.
  Аналогично если использовать систему счисления с большим основанием, однозначные числа останутся такими же.
  И, если исходный массив состоит исключительно из однозначных чисел, то уменьшения размера строки не произойдет.
  А значит нужно представить несколько однозначных числел в виде дву- или трех- значных.

  6. Исходный диапазон от [1, 300], число 0 в него не входит и одновременно является ASCII-символом. Используем его в качестве
  спецсимвола. Кодированные однозначные числа, объединенные в дву- или трех-значные необходимо будет однозначно распознать при десериализации
  и разбить на исходные. Чтобы отличить их от обычных чисел, в сериализованной строке сначала будут идти все кодированные однозначные символы,
  а далее отделенные от них спецсимволом дву- и трех- значные.
  Но диапазона [1, 127] недостаточно чтобы закодировать 300 чисел, для этого разобъем входной диапазон на 3 части по 100 чисел 
  закодируем соответствующими в ASCII таблице(например, предварительно вычтя какое-то число, чтобы попасть в интервал) и также отделим спецсимволом.
  По итогу получим: {однозначные числа}0{числа от [10-127]}0{числа от [128-254]}0{числа от [255-300]}

*/
